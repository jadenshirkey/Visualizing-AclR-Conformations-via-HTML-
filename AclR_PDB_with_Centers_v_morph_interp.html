<script>
(function(){
  function ensure(cb){
    if (window.$3Dmol) return cb();
    var s=document.createElement('script');
    s.src="https://unpkg.com/3dmol@2.0.4/build/3Dmol-min.js";
    s.onload=cb;
    document.head.appendChild(s);
  }
  ensure(init);

  function init(){
    
    // ---------------------------------------------------------
    // KEEP YOUR EXISTING PDBS DATA HERE. 
    // Do not delete your PDB strings.
    // ---------------------------------------------------------
    const PDBS = {
       "APO_AA'": "ATOM      1  N   ASN A  27...", // (Your full APO_AA' string here)
       "APO_BC": "ATOM...",                         // (Your full APO_BC string here)
       "LIGAND_OFF": "ATOM...",                     // (Your full LIGAND_OFF string here)
       "LIGAND_ON": "ATOM..."                       // (Your full LIGAND_ON string here)
    };
    // Re-paste your full PDBS object from your original file above ^^^
    
    
    // States participating in morph animation
    const BASE_MORPH_SEQUENCE = ["APO_AA'", "LIGAND_OFF", "LIGAND_ON"];

    const RAW_CENTERS = {"APO_AA'": [{"label": "Ligand Binding Domain [Protomer 1]", "x": 20.040000915527344, "y": 17.3799991607666, "z": 40.65999984741211}, {"label": "Ligand Binding Domain [Protomer 2]", "x": 48.310001373291016, "y": 21.139999389648438, "z": 51.93000030517578}, {"label": "DNA Binding Domain [Protomer 1]", "x": 40.619998931884766, "y": 36.68000030517578, "z": 32.349998474121094}, {"label": "DNA Binding Domain [Protomer 2]", "x": 24.229999542236328, "y": 37.15999984741211, "z": 57.2400016784668}], "APO_BC": [{"label": "Ligand Binding Domain [Protomer 1]", "x": 20.149999618530273, "y": 17.3799991607666, "z": 40.63999938964844}, {"label": "Ligand Binding Domain [Protomer 2]", "x": 48.650001525878906, "y": 21.459999084472656, "z": 51.939998626708984}, {"label": "DNA Binding Domain [Protomer 1]", "x": 40.380001068115234, "y": 36.72999954223633, "z": 32.45000076293945}, {"label": "DNA Binding Domain [Protomer 2]", "x": 24.459999084472656, "y": 37.310001373291016, "z": 57.15999984741211}], "LIGAND_OFF": [{"label": "Ligand Binding Domain [Protomer 1]", "x": 20.329999923706055, "y": 17.6200008392334, "z": 40.34000015258789}, {"label": "Ligand Binding Domain [Protomer 2]", "x": 48.65999984741211, "y": 20.350000381469727, "z": 51.7400016784668}, {"label": "DNA Binding Domain [Protomer 1]", "x": 39.529998779296875, "y": 36.33000183105469, "z": 33.25}, {"label": "DNA Binding Domain [Protomer 2]", "x": 26.889999389648438, "y": 36.77000045776367, "z": 56.79999923706055}], "LIGAND_ON": [{"label": "Ligand Binding Domain [Protomer 1]", "x": 20.329999923706055, "y": 16.040000915527344, "z": 40.54999923706055}, {"label": "Ligand Binding Domain [Protomer 2]", "x": 47.150001525878906, "y": 19.65999984741211, "z": 48.52000045776367}, {"label": "DNA Binding Domain [Protomer 1]", "x": 40.02000045776367, "y": 40.099998474121094, "z": 32.52000045776367}, {"label": "DNA Binding Domain [Protomer 2]", "x": 23.549999237060547, "y": 41.439998626708984, "z": 48.86000061035156}]};

    const CHAIN_A = 0x800000; // maroon
    const CHAIN_B = 0xffffff; // white
    const YELLOW  = 0xFFD700; // Tyr44
    const LIME    = 0x32CD32; // Phe62
    const RED     = 0xFF0000; // Ser57
    const DASH_GRAY = 0x9ca3af;

    let state = "LIGAND_OFF";
    const el = (id)=>document.getElementById(id);
    const viewer = $3Dmol.createViewer('viewer', {
      backgroundColor: 'black',
      antialias: false,
      disableFog: true,
    });
    let baselineView = null;

    // --- UI Elements (Status & Legend) ---
    const status = document.createElement('div');
    status.className = 'status';
    const legend = document.createElement('div');
    legend.className = 'legend';
    legend.innerHTML = `
      <div><b>PROTOMERS:</b></div>
      <div><span style="display:inline-block;width:10px;height:10px;background:#800000;margin-right:6px;"></span>Chain A</div>
      <div><span style="display:inline-block;width:10px;height:10px;background:#ffffff;margin-right:6px;border:1px solid #ccc;box-sizing:border-box;"></span>Chain B</div>
      <div><b>RESIDUES:</b></div>
      <div><span style="display:inline-block;width:10px;height:10px;background:#ffd700;margin-right:6px;"></span>Tyr44</div>
      <div><span style="display:inline-block;width:10px;height:10px;background:#ff0000;margin-right:6px;"></span>Ser57</div>
      <div><span style="display:inline-block;width:10px;height:10px;background:#32cd32;margin-right:6px;"></span>Phe62</div>
      <div style="margin-top:6px;opacity:.75;">Ligand: C8-Acyl-Cyclo-Lysine</div>`;
    document.getElementById('viewer').appendChild(status);
    document.getElementById('viewer').appendChild(legend);

    // --- Legend Dragging & Mobile Logic ---
    let isDragging = false;
    let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

    function isMobileView() { return window.innerWidth < 768; }

    function resetLegendPosition() {
      xOffset = 0; yOffset = 0;
      legend.style.transform = '';
      if (!isMobileView()) legend.style.transform = 'translate(-50%, -50%)';
      else if (window.innerWidth >= 480) legend.style.transform = 'translate(-50%, 0)';
      else legend.style.transform = 'none';
    }

    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(resetLegendPosition, 250);
    });

    legend.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);
    legend.addEventListener('touchstart', dragStart, { passive: false });
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('touchend', dragEnd);

    function dragStart(e) {
      const event = e.type === 'touchstart' ? e.touches[0] : e;
      initialX = event.clientX - xOffset;
      initialY = event.clientY - yOffset;
      if (e.target === legend || legend.contains(e.target)) isDragging = true;
    }
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        const event = e.type === 'touchmove' ? e.touches[0] : e;
        currentX = event.clientX - initialX;
        currentY = event.clientY - initialY;
        xOffset = currentX; yOffset = currentY;
        legend.style.transform = 'translate(' + currentX + 'px, ' + currentY + 'px)';
      }
    }
    function dragEnd(e) {
      initialX = currentX; initialY = currentY; isDragging = false;
    }

    // --- Legend Toggle ---
    (function initLegendToggle() {
      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'legend-toggle';
      toggleBtn.textContent = !isMobileView() ? 'Hide Legend' : 'Show Legend';
      
      if (isMobileView()) {
          legend.classList.add('hidden');
          toggleBtn.classList.add('collapsed');
      }

      toggleBtn.addEventListener('click', () => {
        const isVisible = !legend.classList.contains('hidden');
        if (isVisible) {
          legend.classList.add('hidden');
          toggleBtn.classList.add('collapsed');
          toggleBtn.textContent = 'Show Legend';
        } else {
          legend.classList.remove('hidden');
          toggleBtn.classList.remove('collapsed');
          toggleBtn.textContent = 'Hide Legend';
        }
      });
      document.getElementById('viewer').appendChild(toggleBtn);
    })();

    // --- Morph Logic Helpers ---
    function parsePDBAtoms(pdbString) {
      if (!pdbString) return [];
      const atoms = [];
      const lines = pdbString.split(/\r?\n/);
      for (const line of lines) {
        if (!line.startsWith("ATOM")) continue;
        atoms.push({
          record: line.slice(0, 6).trim(),
          atomName: line.slice(12, 16).trim(),
          altLoc: line[16] || " ",
          resName: line.slice(17, 20).trim(),
          chain: line[21] || " ",
          resSeq: parseInt(line.slice(22, 26), 10),
          iCode: line[26] || " ",
          x: parseFloat(line.slice(30, 38)),
          y: parseFloat(line.slice(38, 46)),
          z: parseFloat(line.slice(46, 54)),
          line: line
        });
      }
      return atoms;
    }

    function atomKey(a) {
      return [a.chain, a.resSeq, a.iCode, a.resName, a.atomName, a.altLoc].join("|");
    }

    function atomKeySorter(k1, k2) {
      // Simple sort to keep atoms aligned
      return k1.localeCompare(k2);
    }

    function interpolateFrames(a, b, nInter) {
      const frames = [];
      const N = a.length;
      for (let k = 1; k <= nInter; k++) {
        const t = k / (nInter + 1);
        const frame = new Array(N);
        for (let i = 0; i < N; i++) {
          frame[i] = [
            (1 - t) * a[i][0] + t * b[i][0],
            (1 - t) * a[i][1] + t * b[i][1],
            (1 - t) * a[i][2] + t * b[i][2]
          ];
        }
        frames.push(frame);
      }
      return frames;
    }

    function formatCoord(v) {
      return v.toFixed(3).toString().padStart(8, " ");
    }

    // **UPDATED: Fixes the newline bug (\n instead of \\n)**
    function buildInterpolatedMultiPDB(sequenceOrder) {
      try {
        const seq = sequenceOrder || BASE_MORPH_SEQUENCE;
        if (!seq.every(s => PDBS[s])) {
          console.warn("[Morph] Missing PDB data.");
          return "";
        }
        const maps = seq.map(s => {
            const atoms = parsePDBAtoms(PDBS[s]);
            const map = new Map();
            for (const a of atoms) {
                if (a.record !== "ATOM") continue;
                map.set(atomKey(a), a);
            }
            return map;
        });
        const refMap = maps[0];
        const commonKeys = [];
        for (const key of refMap.keys()) {
            if (maps.every(m => m.has(key))) commonKeys.push(key);
        }
        if (!commonKeys.length) return "";
        commonKeys.sort(atomKeySorter);

        const coordSets = maps.map(m => {
            const arr = [];
            for (const key of commonKeys) {
                const a = m.get(key);
                arr.push([a.x, a.y, a.z]);
            }
            return arr;
        });

        const N_INTER = 20; // Interpolation steps
        const frames = [];
        for(let i = 0; i < coordSets.length; i++) {
            const start = coordSets[i];
            const end = coordSets[(i + 1) % coordSets.length];
            frames.push(start);
            frames.push(...interpolateFrames(start, end, N_INTER));
        }

        const apoTemplate = [];
        for (const key of commonKeys) apoTemplate.push(refMap.get(key));

        let modelIndex = 1;
        let out = "";
        const N_ATOMS = apoTemplate.length;

        for (const frame of frames) {
          out += "MODEL     " + ("" + modelIndex).padStart(4, " ") + "\n";
          for (let i = 0; i < N_ATOMS; i++) {
            const tmpl = apoTemplate[i];
            const [x, y, z] = frame[i];
            const line = tmpl.line.slice(0, 30)
                       + formatCoord(x)
                       + formatCoord(y)
                       + formatCoord(z)
                       + tmpl.line.slice(54);
            out += line + "\n"; 
          }
          out += "ENDMDL\n";
          modelIndex++;
        }
        return out;
      } catch (e) {
        console.error("[Morph] Error:", e);
        return "";
      }
    }

    // **UPDATED: Run morph without flipping camera, starting from current state**
    function runMorphCycle() {
      if (!el('showPDB').checked) {
        alert("Enable 'Show PDB' to run the morph.");
        return;
      }

      // 1. Capture current camera
      const currentView = viewer.getView();

      // 2. Reorder sequence so morph starts at current state
      const currentState = state;
      const startIndex = BASE_MORPH_SEQUENCE.indexOf(currentState);
      let morphSequence = [];
      if (startIndex > -1) {
          morphSequence = [
              ...BASE_MORPH_SEQUENCE.slice(startIndex),
              ...BASE_MORPH_SEQUENCE.slice(0, startIndex)
          ];
      } else {
          morphSequence = BASE_MORPH_SEQUENCE;
      }

      const multiPDB = buildInterpolatedMultiPDB(morphSequence);
      if (!multiPDB.trim()) return;

      stopSpin();
      if (viewer.stopAnimate) viewer.stopAnimate();

      viewer.clear();
      const morphModel = viewer.addModelsAsFrames(multiPDB, "pdb");
      
      showProtein(morphModel);
      if (el('showSidechains').checked) {
          try { showSidechains(morphModel); } catch (e) {}
      }

      // 3. Restore camera immediately
      viewer.setView(currentView);
      viewer.render();

      viewer.animate({ loop: "forward", reps: 0, interval: 50 });
    }

    // --- Standard Drawing Functions ---
    let spinRAF = null;
    function startSpin(){
      stopSpin();
      let last = performance.now();
      const degPerSec = 10;
      function step(now){
        const dt = (now - last)/1000; last = now;
        viewer.rotate(degPerSec * dt, {x:0, y:1, z:0});
        viewer.render();
        spinRAF = requestAnimationFrame(step);
      }
      spinRAF = requestAnimationFrame(step);
    }
    function stopSpin(){
      if (spinRAF) cancelAnimationFrame(spinRAF);
      spinRAF = null;
    }

    function showProtein(model){
      if (el('fastMode').checked) {
        model.setStyle({chain:'A'}, {line: { color: CHAIN_A, linewidth: 2 }});
        model.setStyle({chain:'B'}, {line: { color: CHAIN_B, linewidth: 2 }});
      } else {
        model.setStyle({chain:'A'}, {cartoon: { color: CHAIN_A, opacity: 0.98 }});
        model.setStyle({chain:'B'}, {cartoon: { color: CHAIN_B, opacity: 0.98 }});
      }
      model.setStyle({resn:'LIG'}, {stick: { radius: 0.25 }, sphere: { radius: 0.55 }});
    }

    function showSidechains(model){
      const targets = [
        { chain: 'A', resi: 44, color: YELLOW },
        { chain: 'B', resi: 44, color: YELLOW },
        { chain: 'A', resi: 57, color: RED },
        { chain: 'B', resi: 57, color: RED },
        { chain: 'A', resi: 62, color: LIME },
        { chain: 'B', resi: 62, color: LIME },
      ];
      targets.forEach(t => {
        const cartoonColor = (t.chain === 'B') ? CHAIN_B : CHAIN_A;
        model.setStyle(
          { chain: t.chain, resi: t.resi },
          {
            cartoon: { color: cartoonColor, opacity: 0.98 },
            stick:   { radius: 0.25, color: t.color }
          }
        );
      });
    }

    function labelAt(text, p){
      if (!el('showLabels').checked) return;
      const match = text.match(/^(.+?)\s+(\[Protomer \d+\])$/);
      const dy = 1.5;
      if (match) {
        viewer.addLabel(match[1], { position: {x:p.x, y:p.y+dy, z:p.z}, backgroundOpacity: 0.6, fontSize: 14 });
        viewer.addLabel(match[2], { position: {x:p.x, y:p.y-dy, z:p.z}, backgroundOpacity: 0.6, fontSize: 14 });
      } else {
        viewer.addLabel(text, { position: p, backgroundOpacity: 0.6, fontSize: 14 });
      }
    }

    function addCenters(){
      const pts = RAW_CENTERS[state] || [];
      let count=0;
      for (const p of pts) {
        const ch = (p.label.includes('Protomer 2')) ? 'B' : 'A';
        const color = (ch === 'B') ? CHAIN_A : CHAIN_B;
        if (el('showCenters').checked) {
          const shape = viewer.addShape({color: color, opacity: 1.0});
          shape.addSphere({ center: {x:p.x, y:p.y, z:p.z}, radius: 2.2, color: color, opacity: 1.0 });
          // Add distance lines only if centers are visible
          const l1 = pts.find(q => q.label === "Ligand Binding Domain [Protomer 1]");
          const l2 = pts.find(q => q.label === "Ligand Binding Domain [Protomer 2]");
          if(p === l1 && l2) addDashedDistance(l1, l2);
          
          const d1 = pts.find(q => q.label === "DNA Binding Domain [Protomer 1]");
          const d2 = pts.find(q => q.label === "DNA Binding Domain [Protomer 2]");
          if(p === d1 && d2) addDashedDistance(d1, d2);
        }
        labelAt(p.label, {x:p.x, y:p.y, z:p.z});
        count++;
      }
      return count;
    }

    function addDashedDistance(a, b){
      const start = {x:a.x, y:a.y, z:a.z};
      const end   = {x:b.x, y:b.y, z:b.z};
      const dist = Math.sqrt(Math.pow(b.x-a.x,2) + Math.pow(b.y-a.y,2) + Math.pow(b.z-a.z,2));
      viewer.addLine({ start: start, end: end, dashed: true, dashLength: 2.0, gapLength: 1.2, linewidth: 3, color: 10265519 });
      const mid = {x: (a.x+b.x)/2, y: (a.y+b.y)/2, z: (a.z+b.z)/2};
      if(el('showCenters').checked) viewer.addLabel(dist.toFixed(1) + " Å", { position: mid, backgroundOpacity: 0.6, fontSize: 14 });
    }

    function applyMobileViewAdjustments() {
      if (isMobileView()) {
        const h = document.getElementById('viewer').clientHeight;
        viewer.translate(0, -h * 0.25);
        viewer.zoom(0.5);
        viewer.render();
      }
    }

    // **UPDATED: Draw function preserves camera**
    function draw(){
      let previousView = null;
      try { previousView = viewer.getView(); } catch(e){}

      stopSpin();
      if (viewer.stopAnimate) viewer.stopAnimate();
      viewer.clear();
      
      let centersCount = 0;
      if (el('showPDB').checked) {
        const pdb = PDBS[state] || "";
        if (pdb.trim().length) {
          const m = viewer.addModel(pdb, "pdb");
          showProtein(m);
          if (el('showSidechains').checked) showSidechains(m);
        } else {
          viewer.addLabel("No PDB embedded for " + state, { fontSize: 16, backgroundOpacity: 0.6 });
        }
      }
      
      centersCount = addCenters();
      
      // Restore view if available, else default zoom
      if(previousView) viewer.setView(previousView);
      else viewer.zoomTo();

      viewer.render();
      
      status.textContent = "State: " + state +
        " · Mode: " + (el('fastMode').checked ? "Fast (trace)" : "Cartoon") +
        " · Sidechains: " + (el('showSidechains').checked ? "ON" : "OFF") +
        " · Centers: " + (el('showCenters').checked ? "ON" : "OFF");
      
      if (el('spin').checked) startSpin();
    }

    // --- Event Listeners ---
    el('state').onchange = ()=>{ state = el('state').value; draw(); };
    el('showPDB').onchange = draw;
    el('fastMode').onchange = draw;
    el('showCenters').onchange = draw;
    el('showSidechains').onchange = draw;
    el('showLabels').onchange = draw;
    el('spin').onchange = ()=> { if (el('spin').checked) startSpin(); else stopSpin(); };
    el('morph').onclick = runMorphCycle;
    
    el('reset').onclick = () => {
      el('reset').classList.add('button-active');
      setTimeout(() => el('reset').classList.remove('button-active'), 200);
      if (baselineView) viewer.setView(baselineView);
      else viewer.zoomTo();
      draw();
    };

    // --- Initialization ---
    draw();
    viewer.rotate(180, {x:1, y:0, z:0});
    applyMobileViewAdjustments();
    viewer.render();
    baselineView = viewer.getView();
    
    // Touch/Zoom handlers
    const vEl = document.getElementById('viewer');
    vEl.addEventListener('wheel', e => {
        e.preventDefault(); e.stopImmediatePropagation();
        viewer.zoom(e.deltaY > 0 ? 0.9 : 1.1);
    }, { passive: false, capture: true });

    let lastCenter = null;
    vEl.addEventListener('touchstart', e => {
        if (e.touches.length === 2) lastCenter = { 
            x: (e.touches[0].clientX + e.touches[1].clientX)/2, 
            y: (e.touches[0].clientY + e.touches[1].clientY)/2 
        };
    }, {passive: false});
    vEl.addEventListener('touchmove', e => {
        if (e.touches.length === 2 && lastCenter) {
            e.preventDefault();
            const current = { 
                x: (e.touches[0].clientX + e.touches[1].clientX)/2, 
                y: (e.touches[0].clientY + e.touches[1].clientY)/2 
            };
            if(Math.abs(current.x - lastCenter.x) > 1 || Math.abs(current.y - lastCenter.y) > 1){
                viewer.translate(current.x - lastCenter.x, -(current.y - lastCenter.y));
                viewer.render();
            }
            lastCenter = current;
        }
    }, {passive: false});
  }
})();
</script>
