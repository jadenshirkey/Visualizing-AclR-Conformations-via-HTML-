function buildInterpolatedMultiPDB(sequenceOrder) {
      try {
        const seq = sequenceOrder || ["APO_AA'", "LIGAND_OFF", "LIGAND_ON"];
        
        // 1. Check Data
        if (seq.some(s => !PDBS[s])) {
           console.error("[Morph] Missing data for:", seq);
           return "";
        }

        // 2. Parse States
        const maps = seq.map(s => {
            const m = new Map();
            parsePDBAtoms(PDBS[s]).forEach(a => m.set(a.key, a));
            return m;
        });

        // 3. Find Common Atoms
        const refMap = maps[0];
        const commonKeys = [];
        for (const key of refMap.keys()) {
            if (maps.every(m => m.has(key))) commonKeys.push(key);
        }

        if (commonKeys.length === 0) {
            console.error("[Morph] Zero common atoms found.");
            return "";
        }
        
        // Sort by Chain -> Residue -> Atom
        commonKeys.sort((a, b) => {
            const atomA = refMap.get(a);
            const atomB = refMap.get(b);
            if (atomA.chain !== atomB.chain) return atomA.chain.localeCompare(atomB.chain);
            if (atomA.resSeq !== atomB.resSeq) return atomA.resSeq - atomB.resSeq;
            return 0; 
        });

        // 4. Generate Interpolated Frames
        const N_STEPS = 20; 
        const frames = [];
        const fmt = (num) => num.toFixed(3).padStart(8, " "); // Fixed width float

        for (let i = 0; i < maps.length; i++) {
            const startMap = maps[i];
            const endMap = maps[(i + 1) % maps.length];
            
            for (let step = 0; step <= N_STEPS; step++) {
                if (step === N_STEPS && i < maps.length - 1) continue; 

                const t = step / (N_STEPS + 1);
                const frameLines = [];

                for (const key of commonKeys) {
                    const aStart = startMap.get(key);
                    const aEnd = endMap.get(key);
                    
                    const x = (1 - t) * aStart.x + t * aEnd.x;
                    const y = (1 - t) * aStart.y + t * aEnd.y;
                    const z = (1 - t) * aStart.z + t * aEnd.z;

                    // RECONSTRUCT PDB LINE (Strict Columns)
                    // Columns are 1-based in spec, 0-based in JS string
                    // 0-5: "ATOM  "
                    // 6-10: Serial
                    // 12-15: Atom Name
                    // 16: AltLoc
                    // 17-19: ResName
                    // 21: Chain
                    // 22-25: ResSeq
                    // 30-54: X, Y, Z
                    
                    const line = 
                        "ATOM  " + 
                        aStart.serial.toString().padStart(5, " ") + " " +
                        aStart.atomName.padEnd(4, " ") +
                        aStart.altLoc +
                        aStart.resName.padStart(3, " ") + " " + // Fixed: Single space here
                        aStart.chain +
                        aStart.resSeq.toString().padStart(4, " ") +
                        aStart.iCode + "   " +
                        fmt(x) + fmt(y) + fmt(z) +
                        "  1.00  0.00           " + 
                        aStart.atomName.substring(0,1);
                    
                    frameLines.push(line);
                }
                frames.push(frameLines);
            }
        }

        // 5. Build Final String
        let out = "";
        let modelIdx = 1;
        
        for (const frameLines of frames) {
            out += "MODEL     " + modelIdx.toString().padStart(4, " ") + "\n";
            out += frameLines.join("\n") + "\n";
            out += "ENDMDL\n";
            modelIdx++;
        }

        return out;

      } catch (e) {
        console.error("[Morph] Build Error:", e);
        return "";
      }
    }
